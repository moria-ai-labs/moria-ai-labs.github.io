<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL CTE Visualizer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- vis-network for graph visualization -->
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        /* Custom styles for vis-network graph */
        #network {
            width: 100%;
            height: 600px;
            border: 1px solid #4a5568; /* border-gray-700 */
            background-color: #1a202c; /* bg-gray-900 */
            border-radius: 0.5rem; /* rounded-lg */
        }
        /* Style for vis-network tooltips */
        .vis-tooltip {
            background-color: #2d3748 !important; /* bg-gray-800 */
            border: 1px solid #4a5568 !important; /* border-gray-700 */
            color: #e2e8f0 !important; /* text-gray-300 */
            padding: 8px !important;
            border-radius: 6px !important;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06) !important;
            white-space: pre-wrap; /* Allows newlines in tooltips */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans antialiased">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white">SQL CTE Visualizer</h1>
            <p class="text-lg text-gray-400 mt-2">Paste your SQL with CTEs below to see the dependency graph.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Input Section -->
            <div class="flex flex-col">
                <label for="sqlInput" class="mb-2 font-semibold text-gray-300">SQL Query:</label>
                <textarea id="sqlInput" class="w-full h-96 p-4 bg-gray-800 border border-gray-700 rounded-lg text-gray-200 font-mono text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200 resize-none">-- Example Query:
WITH 
  regional_sales AS (
    SELECT 
      region, 
      SUM(amount) AS total_sales
    FROM sales
    GROUP BY region
  ),
  
  top_regions AS (
    SELECT region
    FROM regional_sales
    WHERE total_sales > (SELECT AVG(total_sales) FROM regional_sales)
  ),

  customer_stats AS (
    SELECT
      c.customer_id,
      c.name,
      COUNT(s.sale_id) as purchase_count
    FROM customers c
    JOIN sales s ON c.customer_id = s.customer_id
    GROUP BY c.customer_id, c.name
  )

SELECT 
  e.name as employee_name,
  s.region
FROM employees e
JOIN top_regions s ON e.region = s.region;
</textarea>
                <button id="visualizeBtn" class="mt-4 px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-blue-500 transition duration-200 shadow-lg">
                    Visualize
                </button>
            </div>

            <!-- Output Section -->
            <div class="flex flex-col">
                 <label for="network" class="mb-2 font-semibold text-gray-300">Dependency Graph:</label>
                <div id="network"></div>
            </div>
        </main>
        
        <footer class="text-center mt-12 text-gray-500">
            <p>Created to help understand complex SQL query structures.</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const sqlInput = document.getElementById('sqlInput');
            const visualizeBtn = document.getElementById('visualizeBtn');
            const networkContainer = document.getElementById('network');

            let network = null;

            /**
             * Parses the SQL query to extract nodes (CTEs, tables) and edges (dependencies).
             * @param {string} sql - The SQL query string.
             * @returns {{nodes: Array, edges: Array}} - The nodes and edges for the graph.
             */
            function parseSql(sql) {
                const nodes = [];
                const edges = [];
                const nodeIds = new Set();
                
                // Remove comments to prevent parsing errors
                const cleanSql = sql.replace(/--.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();

                const sources = new Map(); // Map to store CTE names and their bodies

                // --- Step 1: Identify all CTEs and the final query ---
                let finalQuery = cleanSql;
                const withKeywordIndex = cleanSql.toUpperCase().indexOf('WITH');

                if (withKeywordIndex !== -1) {
                    let openParens = 0;
                    let lastParenIndex = -1;
                    let withClauseEndIndex = -1;

                    // A more robust way to find the end of the WITH clause block
                    for (let i = withKeywordIndex; i < cleanSql.length; i++) {
                        if (cleanSql[i] === '(') openParens++;
                        if (cleanSql[i] === ')') {
                            openParens--;
                            lastParenIndex = i;
                        }
                        // The WITH block ends right before the final SELECT that is not in a subquery
                        if (openParens === 0 && lastParenIndex > withKeywordIndex) {
                            const followingText = cleanSql.substring(lastParenIndex + 1).trim();
                            if (followingText.toUpperCase().startsWith('SELECT') || followingText.toUpperCase().startsWith('(')) {
                                withClauseEndIndex = lastParenIndex;
                                break;
                            }
                        }
                    }
                    
                    if (withClauseEndIndex !== -1) {
                        const withBlock = cleanSql.substring(0, withClauseEndIndex + 1);
                        finalQuery = cleanSql.substring(withClauseEndIndex + 1);

                        const cteRegex = /(\w+)\s+AS\s*\(([\s\S]*?)\)(?=\s*,\s*\w+\s+AS|\s*$)/gi;
                        let cteMatch;
                        while ((cteMatch = cteRegex.exec(withBlock)) !== null) {
                            sources.set(cteMatch[1], cteMatch[2]);
                        }
                    }
                }
                sources.set('_final_query_', finalQuery);

                // --- Step 2: Process each source to find dependencies and create nodes/edges ---
                for (const [sourceName, sourceBody] of sources.entries()) {
                    if (!nodeIds.has(sourceName)) {
                        let nodeConfig = { id: sourceName, label: sourceName };
                        if (sourceName === '_final_query_') {
                            Object.assign(nodeConfig, {
                                label: 'Final Result',
                                shape: 'box',
                                color: { background: '#f97316', border: '#fb923c' },
                                font: { color: '#ffffff' }
                            });
                        } else {
                            Object.assign(nodeConfig, {
                                shape: 'box', // This is a round-edge rectangle by default
                                color: { background: '#2563eb', border: '#60a5fa' },
                                font: { color: '#ffffff' }
                            });
                        }
                        nodes.push(nodeConfig);
                        nodeIds.add(sourceName);
                    }

                    const dependencyRegex = /\b(?:FROM|JOIN)\s+([\w\.]+)(?:\s+(?:AS\s+)?(\w+))?/gi;
                    let match;
                    while ((match = dependencyRegex.exec(sourceBody)) !== null) {
                        const dependencyName = match[1];
                        const alias = match[2] || dependencyName;

                        if (!nodeIds.has(dependencyName)) {
                            const isCte = sources.has(dependencyName);
                            nodes.push({
                                id: dependencyName,
                                label: dependencyName,
                                shape: 'box', 
                                color: isCte 
                                    ? { background: '#2563eb', border: '#60a5fa' }
                                    : { background: '#16a34a', border: '#4ade80' }, // Green for base tables
                                font: { color: '#ffffff' }
                            });
                            nodeIds.add(dependencyName);
                        }
                        
                        const usedFields = new Set();
                        const fieldRegex = new RegExp(`\\b(?:${alias}|${dependencyName})\\.(\\w+)`, 'gi');
                        let fieldMatch;
                        while ((fieldMatch = fieldRegex.exec(sourceBody)) !== null) {
                            usedFields.add(fieldMatch[1]);
                        }

                        edges.push({
                            from: dependencyName,
                            to: sourceName,
                            arrows: 'to',
                            title: usedFields.size > 0 
                                ? `Fields:\n- ${Array.from(usedFields).join('\n- ')}` 
                                : `Dependency on ${dependencyName}`
                        });
                    }
                }

                return { nodes, edges };
            }

            /**
             * Renders the network graph using vis.js.
             * @param {Array} nodes - Array of node objects.
             * @param {Array} edges - Array of edge objects.
             */
            function drawNetwork(nodes, edges) {
                if (network) {
                    network.destroy();
                }
                const data = {
                    nodes: new vis.DataSet(nodes),
                    edges: new vis.DataSet(edges),
                };
                const options = {
                    layout: {
                        hierarchical: {
                            enabled: true,
                            direction: 'LR',
                            sortMethod: 'directed',
                            levelSeparation: 250, // INCREASED: More space between levels
                            nodeSpacing: 150,
                            blockShifting: true, // ADDED: Tries to prevent edge overlap
                            edgeMinimization: true, // ADDED: Tries to minimize crossing
                            parentCentralization: true // ADDED: Centers parents over children
                        },
                    },
                    physics: {
                        enabled: false,
                    },
                    nodes: {
                        font: {
                            size: 14,
                            color: '#e2e8f0'
                        },
                        borderWidth: 2,
                        shadow: true,
                    },
                    edges: {
                        color: {
                            color: '#64748b',
                            highlight: '#f1f5f9',
                            hover: '#94a3b8'
                        },
                        width: 2,
                        smooth: {
                            type: 'cubicBezier',
                            forceDirection: 'horizontal',
                            roundness: 0.4
                        }
                    },
                    interaction: {
                        hover: true,
                        tooltipDelay: 200,
                        dragNodes: true,
                        dragView: true,
                        zoomView: true
                    },
                };
                network = new vis.Network(networkContainer, data, options);
            }

            // --- Event Listeners ---
            visualizeBtn.addEventListener('click', () => {
                try {
                    const sql = sqlInput.value;
                    const { nodes, edges } = parseSql(sql);
                    if (nodes.length === 0) {
                        alert("Could not parse any tables or CTEs. Please check your SQL syntax.");
                        return;
                    }
                    drawNetwork(nodes, edges);
                } catch (error) {
                    console.error('Failed to visualize SQL:', error);
                    alert('An error occurred while parsing the SQL. Check the console for details.');
                }
            });

            // Initial visualization on page load
            visualizeBtn.click();
        });
    </script>

</body>
</html>
